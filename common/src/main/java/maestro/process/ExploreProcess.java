package maestro.process;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import maestro.Agent;
import maestro.api.cache.ICachedWorld;
import maestro.api.pathing.goals.Goal;
import maestro.api.pathing.goals.GoalComposite;
import maestro.api.pathing.goals.GoalXZ;
import maestro.api.pathing.goals.GoalYLevel;
import maestro.api.process.IExploreProcess;
import maestro.api.process.PathingCommand;
import maestro.api.process.PathingCommandType;
import maestro.api.utils.MaestroLogger;
import maestro.api.utils.MyChunkPos;
import maestro.cache.CachedWorld;
import maestro.utils.MaestroProcessHelper;
import net.minecraft.core.BlockPos;
import net.minecraft.world.level.ChunkPos;
import org.slf4j.Logger;

public final class ExploreProcess extends MaestroProcessHelper implements IExploreProcess {
    private static final Logger log = MaestroLogger.get("path");

    private BlockPos explorationOrigin;

    private IChunkFilter filter;

    private int distanceCompleted;

    public ExploreProcess(Agent maestro) {
        super(maestro);
    }

    @Override
    public boolean isActive() {
        return explorationOrigin != null;
    }

    @Override
    public void explore(int centerX, int centerZ) {
        explorationOrigin = new BlockPos(centerX, 0, centerZ);
        distanceCompleted = 0;
    }

    @Override
    public void applyJsonFilter(Path path, boolean invert) throws Exception {
        filter = new JsonChunkFilter(path, invert);
    }

    public IChunkFilter calcFilter() {
        IChunkFilter filter;
        if (this.filter != null) {
            filter = new EitherChunk(this.filter, new MaestroChunkCache());
        } else {
            filter = new MaestroChunkCache();
        }
        return filter;
    }

    @Override
    public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
        if (calcFailed) {
            log.atWarn().addKeyValue("reason", "path_calculation_failed").log("Exploration failed");
            if (Agent.settings().notificationOnExploreFinished.value) {
                logNotification("Exploration failed", true);
            }
            onLostControl();
            return null;
        }
        IChunkFilter filter = calcFilter();
        if (!Agent.settings().disableCompletionCheck.value && filter.countRemain() == 0) {
            log.atInfo().log("Exploration complete - all chunks explored");
            if (Agent.settings().notificationOnExploreFinished.value) {
                logNotification("Explored all chunks", false);
            }
            onLostControl();
            return null;
        }
        Goal[] closestUncached = closestUncachedChunks(explorationOrigin, filter);
        if (closestUncached == null) {
            log.atDebug().log("Awaiting region load from disk");
            return new PathingCommand(null, PathingCommandType.REQUEST_PAUSE);
        }
        return new PathingCommand(
                new GoalComposite(closestUncached),
                PathingCommandType.FORCE_REVALIDATE_GOAL_AND_PATH);
    }

    private Goal[] closestUncachedChunks(BlockPos center, IChunkFilter filter) {
        int chunkX = center.getX() >> 4;
        int chunkZ = center.getZ() >> 4;
        int count =
                Math.min(filter.countRemain(), Agent.settings().exploreChunkSetMinimumSize.value);
        List<BlockPos> centers = new ArrayList<>();
        int renderDistance = Agent.settings().worldExploringChunkOffset.value;
        for (int dist = distanceCompleted; ; dist++) {
            for (int dx = -dist; dx <= dist; dx++) {
                int zval = dist - Math.abs(dx);
                for (int mult = 0; mult < 2; mult++) {
                    int dz = (mult * 2 - 1) * zval; // dz can be either -zval or zval
                    int trueDist = Math.abs(dx) + Math.abs(dz);
                    if (trueDist != dist) {
                        throw new IllegalStateException(
                                String.format(
                                        "Offset %s %s has distance %s, expected %s",
                                        dx, dz, trueDist, dist));
                    }
                    switch (filter.isAlreadyExplored(chunkX + dx, chunkZ + dz)) {
                        case UNKNOWN:
                            return null; // awaiting load
                        case NOT_EXPLORED:
                            break; // note: this breaks the switch not the for
                        case EXPLORED:
                            continue; // note: this continues the for
                        default:
                    }
                    int centerX = ((chunkX + dx) << 4) + 8;
                    int centerZ = ((chunkZ + dz) << 4) + 8;
                    int offset = renderDistance << 4;
                    if (dx < 0) {
                        centerX -= offset;
                    } else {
                        centerX += offset;
                    }
                    if (dz < 0) {
                        centerZ -= offset;
                    } else {
                        centerZ += offset;
                    }
                    centers.add(new BlockPos(centerX, 0, centerZ));
                }
            }
            if (dist % 10 == 0) {
                count =
                        Math.min(
                                filter.countRemain(),
                                Agent.settings().exploreChunkSetMinimumSize.value);
            }
            if (centers.size() >= count) {
                return centers.stream()
                        .map(pos -> createGoal(pos.getX(), pos.getZ()))
                        .toArray(Goal[]::new);
            }
            if (centers.isEmpty()) {
                // we have explored everything from 0 to dist inclusive
                // next time we should start our check at dist+1
                distanceCompleted = dist + 1;
            }
        }
    }

    private static Goal createGoal(int x, int z) {
        if (Agent.settings().exploreMaintainY.value == -1) {
            return new GoalXZ(x, z);
        }
        // don't use a goalblock because we still want isInGoal to return true if X and Z are
        // correct
        // we just want to try and maintain Y on the way there, not necessarily end at that specific
        // Y
        return new GoalXZ(x, z) {
            @Override
            public double heuristic(int x, int y, int z) {
                return super.heuristic(x, y, z)
                        + GoalYLevel.calculate(Agent.settings().exploreMaintainY.value, y);
            }
        };
    }

    private enum Status {
        EXPLORED,
        NOT_EXPLORED,
        UNKNOWN
    }

    private interface IChunkFilter {

        Status isAlreadyExplored(int chunkX, int chunkZ);

        int countRemain();
    }

    private class MaestroChunkCache implements IChunkFilter {

        private final ICachedWorld cache =
                maestro.getWorldProvider().getCurrentWorld().getCachedWorld();

        @Override
        public Status isAlreadyExplored(int chunkX, int chunkZ) {
            int centerX = chunkX << 4;
            int centerZ = chunkZ << 4;
            if (cache.isCached(centerX, centerZ)) {
                return Status.EXPLORED;
            }
            if (!((CachedWorld) cache).regionLoaded(centerX, centerZ)) {
                Agent.getExecutor()
                        .execute(
                                () -> {
                                    ((CachedWorld) cache)
                                            .tryLoadFromDisk(centerX >> 9, centerZ >> 9);
                                });
                return Status.UNKNOWN; // we still need to load regions from disk in order to decide
                // properly
            }
            return Status.NOT_EXPLORED;
        }

        @Override
        public int countRemain() {
            return Integer.MAX_VALUE;
        }
    }

    private class JsonChunkFilter implements IChunkFilter {

        private final boolean
                invert; // if true, the list is interpreted as a list of chunks that are NOT
        // explored, if false, the list is interpreted as a list of chunks that ARE
        // explored
        private final LongOpenHashSet inFilter;
        private final MyChunkPos[] positions;

        private JsonChunkFilter(Path path, boolean invert)
                throws Exception { // ioexception, json exception, etc
            this.invert = invert;
            Gson gson = new GsonBuilder().create();
            positions =
                    gson.fromJson(
                            new InputStreamReader(Files.newInputStream(path)), MyChunkPos[].class);
            log.atInfo()
                    .addKeyValue("position_count", positions.length)
                    .log("Loaded exploration filter positions");
            inFilter = new LongOpenHashSet();
            for (MyChunkPos mcp : positions) {
                inFilter.add(ChunkPos.asLong(mcp.x, mcp.z));
            }
        }

        @Override
        public Status isAlreadyExplored(int chunkX, int chunkZ) {
            if (inFilter.contains(ChunkPos.asLong(chunkX, chunkZ)) ^ invert) {
                // either it's on the list of explored chunks, or it's not on the list of unexplored
                // chunks
                // either way, we have it
                return Status.EXPLORED;
            } else {
                // either it's not on the list of explored chunks, or it's on the list of unexplored
                // chunks
                // either way, it depends on if maestro has cached it so defer to that
                return Status.UNKNOWN;
            }
        }

        @Override
        public int countRemain() {
            if (!invert) {
                // if invert is false, anything not on the list is uncached
                return Integer.MAX_VALUE;
            }
            // but if invert is true, anything not on the list IS assumed cached
            // so we are done if everything on our list is cached!
            int countRemain = 0;
            MaestroChunkCache bcc = new MaestroChunkCache();
            for (MyChunkPos pos : positions) {
                if (bcc.isAlreadyExplored(pos.x, pos.z) != Status.EXPLORED) {
                    // either waiting for it or don't have it at all
                    countRemain++;
                    if (countRemain >= Agent.settings().exploreChunkSetMinimumSize.value) {
                        return countRemain;
                    }
                }
            }
            return countRemain;
        }
    }

    private static class EitherChunk implements IChunkFilter {

        private final IChunkFilter a;
        private final IChunkFilter b;

        private EitherChunk(IChunkFilter a, IChunkFilter b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public Status isAlreadyExplored(int chunkX, int chunkZ) {
            if (a.isAlreadyExplored(chunkX, chunkZ) == Status.EXPLORED) {
                return Status.EXPLORED;
            }
            return b.isAlreadyExplored(chunkX, chunkZ);
        }

        @Override
        public int countRemain() {
            return Math.min(a.countRemain(), b.countRemain());
        }
    }

    @Override
    public void onLostControl() {
        explorationOrigin = null;
    }

    @Override
    public String displayName0() {
        return "Exploring around "
                + explorationOrigin
                + ", distance completed "
                + distanceCompleted
                + ", currently going to "
                + new GoalComposite(closestUncachedChunks(explorationOrigin, calcFilter()));
    }
}
